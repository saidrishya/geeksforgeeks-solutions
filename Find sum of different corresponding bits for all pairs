/*
We define f (X, Y) as number of different corresponding bits in binary representation of X and Y. For example, f (2, 7) = 2, since binary representation of 2 and 7 are 010 and 111, respectively. The first and the third bit differ, so f (2, 7) = 2.

You are given an array of N integers, A1, A2 ,…, AN. Find sum of f(Ai, Aj) for all pairs (i, j) such that 1 ≤ i, j ≤ N. Return the answer modulo 109+7.

Input:

The first line of each input consists of the test cases. The description of T test cases is as follows:

The first line of each test case contains the size of the array, and the second line has the elements of the array.


Output:

In each separate line print sum of all pairs for (i, j) such that 1 ≤ i, j ≤ N and return the answer modulo 109+7.


Constraints:

1 ≤ T ≤ 70
1 ≤ N ≤ 104
-2,147,483,648 ≤ A[i] ≤ 2,147,483,647


Example:

Input:

2
2
2 4
3
1 3 5

Output:

4
8

Working:

A = [1, 3, 5] 

We return

f(1, 1) + f(1, 3) + f(1, 5) +
f(3, 1) + f(3, 3) + f(3, 5) +
f(5, 1) + f(5, 3) + f(5, 5) =

0 + 1 + 1 +
1 + 0 + 2 +
1 + 2 + 0 = 8
*/

#include <bits/stdc++.h>
using namespace std;

#define mod 1000000007;

int bits(int a[], int n)
{
    int ans=0;
    //if(a==b) return 0;
    for(int i=0; i<32; i++)
     {
         int c=0;
         for(int j=0; j<n; j++)
         {
             if(a[j] & (1<<i)) c++;
         }
       ans=(ans+(c*(n-c)*2))%mod;
     }
return ans;
}


int main() {
     int t; cin>>t; while(t--)
     {
         int n; cin>>n;
         int a[n],s=0;
         for(int i=0;i<n;i++) cin>>a[i];
         cout<<bits(a,n)<<endl;
     }
	return 0;
}
